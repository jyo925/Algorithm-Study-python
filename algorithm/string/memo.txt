String Matching 문제는 o(n)으로 해결한다. (중요)
    브루트포스 ---> X

    ** KMP 알고리즘
    a b c d e f g h 에서 d e f g h 를 찾고자 한다.
                    0 0 0 0 0

    반복패턴을 이용
    https://bowbowbow.tistory.com/6

    ** Rolling Hash
    찾고자하는 문자열에 대한 해쉬값을 저장
    첫번째 문자부터 찾고자하는 문자열 길이 만큼 해쉬값을 계산하면서 비교

    -> leetcode 28, 796(회전시켜서)


팰린트롬
    투포인터 이용 o(n)
    -> leetcode 680


Add Srings
    int로 형변환을 하지 않고 2개의 문자열을 덧셈하기
    carry 변수와 //, %를 사용
    문자 하나씩 int로 변환하여 덧셈

    -> leetcode 415


Anagrams
    똑같은 알파벳으로 이루어진 단어들의 집합
    해쉬를 사용 -> key는 정렬값, value는 원래 문자열
    각 단어를 정렬하는데 걸리는 시간, 단어길이를 m 이라고 하면 o(mlogm)
        총 n개의 단어 -> o(nmlongm), 공간복잡도는 m길이의 n개의 문자를 저장할 해쉬 o(nm)
        이 때 m을 정렬하는 o(mlogm)을 단축하는 방법이 존재
            -> 굳이 정렬할 필요가 없고 각 단어가 몇개 존재하는지 개수를 세어서 이걸 해쉬의 키값으로 사용하면 됨?? o(nm)으로 줄어든다.
            -> 키는 a-z 테이블을 하나 만들어서 테이블을 전체 훑어서 각각의 알파벳의 개수가 들어있는 키를 생성




