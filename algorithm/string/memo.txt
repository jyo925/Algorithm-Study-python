String Matching 문제는 o(n)으로 해결한다. (중요)
    - 브루트포스 X 아래 두 방법 중 선택

    ** 1. KMP 알고리즘
    a b c d e f g h 에서 d e f g h 를 찾고자 한다.

    반복패턴을 이용
    https://bowbowbow.tistory.com/6

    ** 2. Rolling Hash
    찾고자하는 문자열에 대한 해쉬값을 저장
    첫번째 문자부터 찾고자하는 문자열 길이 만큼 해쉬값을 계산하면서 비교

    -> leetcode 28, 796(회전시키는 문제, 회전하지 말고 풀어보기)


팰린트롬
    - 투포인터 이용 o(n)

    -> leetcode 680


Add Strings
    - int로 형변환을 하지 않고 2개의 문자열을 덧셈하기(매우 큰 수가 들어올 경우 메모리 문제)
    - carry 변수와 //, %를 사용하자
    - 문자 하나씩을 int로 변환하여 덧셈

    -> leetcode 415


Anagrams
    - 똑같은 알파벳으로 이루어진 단어들의 집합 abc cba bac
    - 해쉬를 사용 -> key는 정렬값, value는 원래 문자열
    - 각 단어를 정렬하는데 걸리는 시간, 단어길이를 m 이라고 하면 o(mlogm)
        총 n개의 단어 -> o(nmlongm), 공간복잡도는 m길이의 n개의 문자를 저장할 해쉬 o(nm)
        이 때 m을 정렬하는 시간복잡도 o(mlogm)을 단축하는 방법이 존재
            -> 굳이 정렬할 필요가 없고 각 단어가 몇개 존재하는지 개수를 세어서 이걸 해쉬의 키값으로 사용하면 됨?? o(nm)으로 줄어든다.
            -> 키는 a-z 테이블을 하나 만들어서 테이블을 전체 훑어서 각각의 알파벳의 개수가 들어있는 키를 생성
            [aba, cbc, baa, adc, ccd, bb] 리스트가 주어졌을 때
            각 요소의 키 값을 a2b1(문자와 개수로 표시)
            a2b1 = [aba, baa]
            c2d1 = [ccd]
            .... 이런식으로 해시맵을 구성하면 mlogm을 m으로 줄일 수 있다. 공간복잡도의 경우 각 알파벳 개수를 저장하는 테이블은 고정사이즈로 o(c)로 변동 X
    -> leetcode 49



Longest Substring without repeats
    - 주어진 문자열에서 겹치지 않는 최대 길이의 Substring을 찾아라
    - 브루트포스로 구현하면 o(n^3) X
    - 투포인터 이용, max_len, begin, end 변수
    - 두번째 포인터가 이동할 때 마다 중복 여부를 판단하기 위한 저장공간(알파벳 해쉬맵 or 테이블 이용)
    - 포인터를 이동시키면서 저장공간에 인덱스 업데이트
    - 저장공간의 값을 보고 중복된 문자로 판단되면 해당 중복문자 인덱스 + 1로 첫번째 포인터 이동 & 저강공간 업데이트
    - 왼쪽 포인터를 잡고 오르쪽으로 진행하기 때문에 슬라이딩 윈도우로 볼 수 있다. -> o(n), o(m)/o(26)

    -> leetcode 3

    ** 슬라이딩 윈도우란?
    - window를 한 칸 옮기는 (w-1)칸은 겹친다.
    - a b c d가 있을 때
        a b c 의 합 = s
        b c d 의 합 = s - a + d 로 구할 수 있다. a와 d 값만 이용하면 됨 ---> o(1)
        즉, 중복되는 값 b, c를 계산하지 않아도 됨
        기존에는 모든 위치마다 합을 구해서 o(nm)이 걸리지만, 슬라이딩 윈도우를 사용하여 o(n)으로 해결
    - 배열 안에 음수가 존재하는 경우 작동 X
